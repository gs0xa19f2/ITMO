=== Структура каталога (ls -a) ===
.
..
arrayset
crawler
directory_structure.txt
hello
implementor
iterative
jarimplementor
mapper
scr.bash
student
tracingproxy
walk

=== Структура каталога (tree -a) ===
.
├── arrayset
│   └── ArraySet.java
├── crawler
│   └── WebCrawler.java
├── directory_structure.txt
├── hello
│   ├── HelloUDPClient.java
│   ├── HelloUDPNonblockingClient.java
│   ├── HelloUDPNonblockingServer.java
│   └── HelloUDPServer.java
├── implementor
│   └── Implementor.java
├── iterative
│   └── IterativeParallelism.java
├── jarimplementor
│   └── JarImplementor.java
├── mapper
│   ├── IterativeParallelism.java
│   └── ParallelMapperImpl.java
├── scr.bash
├── student
│   └── StudentDB.java
├── tracingproxy
│   ├── tests
│   │   ├── Calculator.java
│   │   ├── SimpleCalculator.java
│   │   └── TracingProxyTest.java
│   └── TracingProxy.java
└── walk
    ├── RecursiveWalk.java
    └── Walk.java

12 directories, 20 files

=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/arrayset/ArraySet.java ===
package info.kgeorgiy.ja.gusev.arrayset;

import java.util.*;

public class ArraySet<E> implements NavigableSet<E> {
    private final List<E> elements;
    private final Comparator<? super E> comparator;

    
    public ArraySet(Collection<? extends E> collection, Comparator<? super E> comparator) {
        TreeSet<E> set = new TreeSet<>(comparator);
        set.addAll(collection);
        this.elements = Collections.unmodifiableList(new ArrayList<>(set));
        this.comparator = comparator;
    }

    public ArraySet(List<E> list, Comparator<? super E> comparator) {
        this.elements = Collections.unmodifiableList(list);
        this.comparator = comparator;
    }

    
    @Override
    public E lower(E e) {
        int index = Collections.binarySearch(elements, e, comparator);
        if (index < 0) {
            index = -index - 2;
        } else {
            index--;
        }
        return index >= 0 ? elements.get(index) : null;
    }

    
    @Override
    public E floor(E e) {
        int index = Collections.binarySearch(elements, e, comparator);
        if (index < 0) {
            index = -index - 2;
        }
        return index >= 0 ? elements.get(index) : null;
    }

    
    @Override
    public E ceiling(E e) {
        int index = Collections.binarySearch(elements, e, comparator);
        if (index < 0) {
            index = -index - 1;
        }
        return index < elements.size() ? elements.get(index) : null;
    }

    
    @Override
    public E higher(E e) {
        int index = Collections.binarySearch(elements, e, comparator);
        if (index < 0) {
            index = -index - 1;
        } else {
            index++;
        }
        return index < elements.size() ? elements.get(index) : null;
    }

    
    @Override
    public E pollFirst() {
        throw new UnsupportedOperationException();
    }

    
    @Override
    public E pollLast() {
        throw new UnsupportedOperationException();
    }

    
    @Override
    public NavigableSet<E> descendingSet() {
        return new ArraySet<>(new ReversedList<>(elements), Collections.reverseOrder(comparator));
    }

    
    @Override
    public Iterator<E> descendingIterator() {
        return descendingSet().iterator();
    }

    
    @Override
    public NavigableSet<E> headSet(E toElement, boolean inclusive) {
        int toIndex = findIndex(toElement);
        if (inclusive && toIndex < elements.size() && compare(elements.get(toIndex), toElement) == 0) {
            toIndex++;
        }
        return new ArraySet<>(elements.subList(0, toIndex), comparator);
    }

    
    @Override
    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
        int fromIndex = findIndex(fromElement);
        if (!inclusive && fromIndex < elements.size() && compare(elements.get(fromIndex), fromElement) == 0) {
            fromIndex++;
        }
        return fromIndex >= elements.size() ? new ArraySet<>(Collections.emptyList(), comparator)
                : new ArraySet<>(elements.subList(fromIndex, elements.size()), comparator);
    }

    
    @Override
    public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
        if (compare(fromElement, toElement) > 0) {
            throw new IllegalArgumentException("fromElement > toElement");
        }
        int fromIndex = findIndex(fromElement);
        int toIndex = findIndex(toElement);
        if (!fromInclusive && fromIndex < elements.size() && compare(elements.get(fromIndex), fromElement) == 0) {
            fromIndex++;
        }
        if (toInclusive && toIndex < elements.size() && compare(elements.get(toIndex), toElement) == 0) {
            toIndex++;
        }
        
        if (fromIndex > toIndex) {
            toIndex = fromIndex;
        }
        return new ArraySet<>(elements.subList(fromIndex, toIndex), comparator);
    }

    

    
    @Override
    public SortedSet<E> headSet(E toElement) {
        int index = findIndex(toElement);
        return new ArraySet<>(elements.subList(0, index), comparator);
    }

    
    @Override
    public SortedSet<E> subSet(E fromElement, E toElement) {
        if (compare(fromElement, toElement) > 0) {
            throw new IllegalArgumentException("fromKey > toKey");
        }
        int fromIndex = findIndex(fromElement);
        int toIndex = findIndex(toElement);
        return new ArraySet<>(elements.subList(fromIndex, toIndex), comparator);
    }

    
    @Override
    public SortedSet<E> tailSet(E fromElement) {
        int index = findIndex(fromElement);
        return new ArraySet<>(elements.subList(index, elements.size()), comparator);
    }

    
    private int findIndex(E element) {
        int index = Collections.binarySearch(elements, element, comparator);
        return index < 0 ? -(index + 1) : index;
    }

    
    private int compare(E e1, E e2) {
        if (comparator == null) {
            return ((Comparable<? super E>) e1).compareTo(e2);
        }
        return comparator.compare(e1, e2);
    }

    
    @Override
    public boolean isEmpty() {
        return elements.isEmpty();
    }

    
    @Override
    public Object[] toArray() {
        return elements.toArray();
    }

    
    @Override
    public <T> T[] toArray(T[] a) {
        return elements.toArray(a);
    }

    
    @Override
    public boolean containsAll(Collection<?> c) {
        for (Object item : c) {
            if (!contains(item)) {
                return false;
            }
        }
        return true;
    }

    
    public ArraySet() {
        this.elements = Collections.emptyList();
        this.comparator = null;
    }

    
    public ArraySet(Collection<? extends E> collection) {
        this(collection, null);
    }

    
    @Override
    public int size() {
        return elements.size();
    }

    
    @Override
    public boolean contains(Object o) {
        return Collections.binarySearch(elements, (E) o, comparator) >= 0;
    }

    
    @Override
    public Iterator<E> iterator() {
        return elements.iterator();
    }

    
    @Override
    public Comparator<? super E> comparator() {
        return comparator;
    }

    
    @Override
    public E first() {
        if (elements.isEmpty()) {
            throw new NoSuchElementException();
        }
        return elements.get(0);
    }

    
    @Override
    public E last() {
        if (elements.isEmpty()) {
            throw new NoSuchElementException();
        }
        return elements.get(elements.size() - 1);
    }

    
    @Override
    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean remove(Object o) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void clear() {
        throw new UnsupportedOperationException();
    }

    
    private static class ReversedList<E> extends AbstractList<E> {
        private final List<E> original;

        public ReversedList(List<E> original) {
            this.original = original;
        }

        @Override
        public E get(int index) {
            return original.get(original.size() - 1 - index);
        }

        @Override
        public int size() {
            return original.size();
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/crawler/WebCrawler.java ===
package info.kgeorgiy.ja.gusev.crawler;

import info.kgeorgiy.java.advanced.crawler.*;

import java.io.IOException;
import java.net.MalformedURLException;
import java.util.*;
import java.util.concurrent.*;

public class WebCrawler implements NewCrawler {
    
    private final Downloader downloader;
    
    private final ExecutorService downloadExecutor;
    
    private final ExecutorService extractExecutor;
    
    private final ConcurrentMap<String, Semaphore> hostSemaphores;
    
    private final int maxConnectionsPerHost;
    
    private final int timeout;

    
    public WebCrawler(final Downloader downloader, final int downloaders, final int extractors, final int perHost, final int timeout) {
        this.downloader = downloader;
        this.downloadExecutor = Executors.newFixedThreadPool(downloaders);
        this.extractExecutor = Executors.newFixedThreadPool(extractors);
        this.hostSemaphores = new ConcurrentHashMap<>();
        this.maxConnectionsPerHost = perHost;
        this.timeout = timeout;
    }

    
    public WebCrawler(final Downloader downloader, final int downloaders, final int extractors, final int perHost) {
        this(downloader, downloaders, extractors, perHost, 10); 
    }

    
    @Override
    public Result download(final String url, final int depth) {
        return download(url, depth, Set.of());
    }

    
    @Override
    public Result download(final String url, final int depth, final Set<String> excludes) {
        final Set<String> visitedUrls = ConcurrentHashMap.newKeySet();  
        final Map<String, IOException> downloadErrors = new ConcurrentHashMap<>();  
        final Phaser taskCoordinator = new Phaser(1);  
        final BlockingQueue<String> pendingUrls = new LinkedBlockingQueue<>();  

        pendingUrls.add(url);  

        
        for (int currentDepth = 0; currentDepth < depth; currentDepth++) {
            final List<String> currentBatchUrls = new ArrayList<>(pendingUrls);
            pendingUrls.clear();  
            final int effectiveDepth = depth - currentDepth;  

            currentBatchUrls.stream()
                .filter(link -> isValidLink(link, visitedUrls, excludes))  
                .forEach(link -> initiateDownload(link, effectiveDepth, pendingUrls, excludes, downloadErrors, taskCoordinator));

            taskCoordinator.arriveAndAwaitAdvance();  
        }

        visitedUrls.removeAll(downloadErrors.keySet());  
        return new Result(new ArrayList<>(visitedUrls), downloadErrors);
    }

    
    private boolean isValidLink(final String url, final Set<String> visited, final Set<String> excludes) {
        return !isExcluded(url, excludes) && visited.add(url);
    }

    
    private boolean isExcluded(String url, Set<String> excludes) {
        return excludes.stream().anyMatch(url::contains);
    }

    
    private void initiateDownload(final String url, final int remainingDepth, final BlockingQueue<String> nextUrlsQueue,
                                  final Set<String> excludes, final Map<String, IOException> errors, final Phaser phaser) {
        try {
            final String host = URLUtils.getHost(url);  
            final Semaphore semaphore = hostSemaphores.computeIfAbsent(host, h -> new Semaphore(maxConnectionsPerHost));  

            phaser.register(); 
            downloadExecutor.submit(() -> {
                try {
                    semaphore.acquire();  
                    try {
                        final Document document = downloader.download(url);  
                        if (remainingDepth > 1) {
                            initiateExtract(document, nextUrlsQueue, excludes, phaser);  
                        }
                    } catch (IOException e) {
                        errors.put(url, e);  
                    } finally {
                        semaphore.release();  
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();  
                } finally {
                    phaser.arriveAndDeregister();  
                }
            });
        } catch (MalformedURLException e) {
            errors.put(url, new IOException("Неверный URL: " + url, e));  
        }
    }

    
    private void initiateExtract(final Document document, final BlockingQueue<String> nextUrlsQueue,
                                 final Set<String> excludes, final Phaser phaser) {
        phaser.register();  
        extractExecutor.submit(() -> {
            try {
                document.extractLinks().stream()  
                    .filter(link -> !isExcluded(link, excludes))  
                    .forEach(nextUrlsQueue::offer);  
            } catch (IOException ignored) {
            } finally {
                phaser.arriveAndDeregister();  
            }
        });
    }

    
    @Override
    public void close() {
        shutdownExecutor(downloadExecutor); 
        shutdownExecutor(extractExecutor);  
    }


    private void shutdownExecutor(final ExecutorService executor) {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(timeout, TimeUnit.SECONDS)) {
                executor.shutdownNow();  
            }
        } catch (InterruptedException e) {
            executor.shutdownNow(); 
            Thread.currentThread().interrupt();  
        }
    }

    public static void main(final String[] args) {
        if (args.length < 1 || args.length > 5) {
            System.err.println("Usage: WebCrawler url [depth [downloads [extractors [perHost]]]]");
            return;
        }

        final String url = args[0];
        final int depth = args.length > 1 ? Integer.parseInt(args[1]) : 1;
        final int downloaders = args.length > 2 ? Integer.parseInt(args[2]) : 16;
        final int extractors = args.length > 3 ? Integer.parseInt(args[3]) : 16;
        final int perHost = args.length > 4 ? Integer.parseInt(args[4]) : 16;

        try (WebCrawler crawler = new WebCrawler(new CachingDownloader(1.0), downloaders, extractors, perHost)) {
            final Result result = crawler.download(url, depth);  
            System.out.println("Downloaded: " + result.getDownloaded().size() + " pages");
            System.out.println("Errors: " + result.getErrors().size());
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());  
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/hello/HelloUDPClient.java ===
package info.kgeorgiy.ja.gusev.hello;

import info.kgeorgiy.java.advanced.hello.HelloClient;

import java.io.IOException;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class HelloUDPClient implements HelloClient {
    private static final int TIMEOUT = 1000; 

    @Override
    public void run(String host, int port, String prefix, int threads, int requests) {
        InetAddress address;
        try {
            address = InetAddress.getByName(host);
        } catch (UnknownHostException e) {
            System.err.println("Unknown host: " + host);
            return;
        }
        ExecutorService threadPool = Executors.newFixedThreadPool(threads);
        CountDownLatch latch = new CountDownLatch(threads);
        for (int i = 0; i < threads; i++) {
            final int threadNumber = i;
            threadPool.submit(() -> {
                Thread.currentThread().setName("Client-Thread-" + threadNumber);
                try (DatagramSocket socket = new DatagramSocket()) {
                    socket.setSoTimeout(TIMEOUT);
                    for (int j = 0; j < requests; j++) {
                        String request = prefix + (threadNumber + 1) + "_" + (j + 1);
                        byte[] requestData = request.getBytes(StandardCharsets.UTF_8);
                        DatagramPacket requestPacket = new DatagramPacket(requestData, requestData.length, address, port);
                        while (!Thread.currentThread().isInterrupted()) {
                            try {
                                socket.send(requestPacket);
                                byte[] buffer = new byte[socket.getReceiveBufferSize()];
                                DatagramPacket responsePacket = new DatagramPacket(buffer, buffer.length);
                                socket.receive(responsePacket);
                                String response = new String(responsePacket.getData(), responsePacket.getOffset(), responsePacket.getLength(), StandardCharsets.UTF_8);
                                if (isValidResponse(response, threadNumber + 1, j + 1)) {
                                    System.out.println("Received: " + response);
                                    break;
                                }
                            } catch (SocketTimeoutException e) {
                                
                            } catch (IOException e) {
                                
                            }
                        }
                    }
                } catch (SocketException e) {
                    System.err.println("Socket error: " + e.getMessage());
                } finally {
                    latch.countDown();
                }
            });
        }
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            threadPool.shutdownNow();
        }
    }

    private boolean isValidResponse(String response, int threadNumber, int requestNumber) {
        
        Pattern numberPattern = Pattern.compile("\\p{Nd}+");
        Matcher matcher = numberPattern.matcher(response);
        boolean threadFound = false;
        boolean requestFound = false;
        while (matcher.find()) {
            String numberStr = matcher.group();
            int number = parseUnicodeNumber(numberStr);
            if (number == threadNumber && !threadFound) {
                threadFound = true;
            } else if (number == requestNumber && !requestFound) {
                requestFound = true;
            }
            if (threadFound && requestFound) {
                return true;
            }
        }
        return false;
    }

    private int parseUnicodeNumber(String numberStr) {
        int number = 0;
        for (int i = 0; i < numberStr.length(); i++) {
            char c = numberStr.charAt(i);
            int digit = Character.getNumericValue(c);
            if (digit < 0 || digit > 9) {
                return -1; 
            }
            number = number * 10 + digit;
        }
        return number;
    }

    public static void main(String[] args) {
        if (args.length != 5) {
            System.out.println("Usage: HelloUDPClient <host> <port> <prefix> <threads> <requests>");
            return;
        }
        String host = args[0];
        int port = Integer.parseInt(args[1]);
        String prefix = args[2];
        int threads = Integer.parseInt(args[3]);
        int requests = Integer.parseInt(args[4]);

        HelloUDPClient client = new HelloUDPClient();
        client.run(host, port, prefix, threads, requests);
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/hello/HelloUDPServer.java ===
package info.kgeorgiy.ja.gusev.hello;

import info.kgeorgiy.java.advanced.hello.NewHelloServer;

import java.io.IOException;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.*;
import java.util.ArrayList;
import java.util.List;

public class HelloUDPServer implements NewHelloServer {
    private ExecutorService executor;
    private volatile boolean running = true;
    private final List<DatagramSocket> serverSockets = Collections.synchronizedList(new ArrayList<>());
    private final List<Thread> receiverThreads = Collections.synchronizedList(new ArrayList<>());

    @Override
    public void start(int threads, Map<Integer, String> ports) {
        executor = Executors.newFixedThreadPool(threads);
        for (Map.Entry<Integer, String> entry : ports.entrySet()) {
            int port = entry.getKey();
            String format = entry.getValue();
            try {
                DatagramSocket socket = new DatagramSocket(port);
                serverSockets.add(socket);
                Thread receiver = new Thread(new Receiver(socket, format));
                receiver.start();
                receiverThreads.add(receiver);
            } catch (SocketException e) {
                System.err.println("Error creating socket on port " + port + ": " + e.getMessage());
                stop();
            }
        }
    }

    private class Receiver implements Runnable {
        private final DatagramSocket socket;
        private final String format;

        Receiver(DatagramSocket socket, String format) {
            this.socket = socket;
            this.format = format;
        }

        @Override
        public void run() {
            while (running && !socket.isClosed()) {
                byte[] buffer;
                try {
                    buffer = new byte[socket.getReceiveBufferSize()];
                } catch (SocketException e) {
                    System.err.println("SocketException occurred: " + e.getMessage());
                    buffer = new byte[1024]; 
                }
                DatagramPacket requestPacket = new DatagramPacket(buffer, buffer.length);
                try {
                    socket.receive(requestPacket);
                    
                    String request = new String(requestPacket.getData(), requestPacket.getOffset(), requestPacket.getLength(), StandardCharsets.UTF_8);
                    SocketAddress clientAddress = requestPacket.getSocketAddress();
                    executor.submit(() -> handleRequest(request, format, socket, clientAddress));
                } catch (SocketException e) {
                    
                    break;
                } catch (IOException e) {
                    System.err.println("Error receiving packet on port " + socket.getLocalPort() + ": " + e.getMessage());
                }
            }
        }
    }

    private void handleRequest(String request, String format, DatagramSocket socket, SocketAddress clientAddress) {
        String response = format.replace("$", request);
        byte[] responseData = response.getBytes(StandardCharsets.UTF_8);
        DatagramPacket responsePacket = new DatagramPacket(responseData, responseData.length, clientAddress);
        try {
            synchronized (socket) {
                socket.send(responsePacket);
            }
        } catch (IOException e) {
            System.err.println("Error sending response to " + clientAddress + ": " + e.getMessage());
        }
    }

    @Override
    public void close() {
        stop();
    }

    private void stop() {
        running = false;
        
        synchronized (serverSockets) {
            for (DatagramSocket s : serverSockets) {
                if (!s.isClosed()) {
                    s.close();
                }
            }
            serverSockets.clear();
        }
        
        synchronized (receiverThreads) {
            for (Thread t : receiverThreads) {
                t.interrupt();
            }
            receiverThreads.clear();
        }
        
        if (executor != null && !executor.isShutdown()) {
            executor.shutdownNow();
            try {
                if (!executor.awaitTermination(1000, TimeUnit.MILLISECONDS)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }


    
    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Использование: HelloUDPServer <port> <threads>");
            System.out.println("Или для мультипорта: HelloUDPServer <threads> <port1> <format1> <port2> <format2> ...");
            return;
        }

        HelloUDPServer server = new HelloUDPServer();
        try {
            if (args.length == 2) {
                int port = Integer.parseInt(args[0]);
                int threads = Integer.parseInt(args[1]);
                server.start(threads, Map.of(port, "Hello, $"));
            } else {
                int threads = Integer.parseInt(args[0]);
                if ((args.length - 1) % 2 != 0) {
                    System.err.println("Неправильное количество аргументов для мультипорта.");
                    return;
                }
                Map<Integer, String> ports = new ConcurrentHashMap<>();
                for (int i = 1; i < args.length; i += 2) {
                    int port = Integer.parseInt(args[i]);
                    String format = args[i + 1];
                    ports.put(port, format);
                }
                server.start(threads, ports);
            }
        } catch (NumberFormatException e) {
            System.err.println("Ошибка парсинга чисел: " + e.getMessage());
            server.close();
        }
    }
}

=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/hello/HelloUDPNonblockingServer.java ===
package info.kgeorgiy.ja.gusev.hello;

import info.kgeorgiy.java.advanced.hello.NewHelloServer;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.net.StandardSocketOptions;
import java.nio.channels.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;


    public static void main(String[] args) {
        if (args.length < 2 || (args.length - 1) % 2 != 0) {
            System.out.println("Usage: HelloUDPNonblockingServer <port> <threads>");
            System.out.println("Or for multiple ports: HelloUDPNonblockingServer <threads> <port1> <format1> <port2> <format2> ...");
            return;
        }

        Map<Integer, String> ports = new HashMap<>();

        if (args.length == 2) {
            int port = Integer.parseInt(args[0]);
            String format = args[1];
            ports.put(port, format);
        } else {
            int threads = Integer.parseInt(args[0]); 
            for (int i = 1; i < args.length; i += 2) {
                int port = Integer.parseInt(args[i]);
                String format = args[i + 1];
                ports.put(port, format);
            }
        }

        HelloUDPNonblockingServer server = new HelloUDPNonblockingServer();
        server.start(1, ports);
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/hello/HelloUDPNonblockingClient.java ===
package info.kgeorgiy.ja.gusev.hello;

import info.kgeorgiy.java.advanced.hello.HelloClient;

import java.io.IOException;
import java.net.*;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


    public static void main(String[] args) {
        if (args.length != 5) {
            System.out.println("Usage: HelloUDPNonblockingClient <host> <port> <prefix> <threads> <requests>");
            return;
        }

        String host = args[0];
        int port = Integer.parseInt(args[1]);
        String prefix = args[2];
        int threads = Integer.parseInt(args[3]);
        int requests = Integer.parseInt(args[4]);

        new HelloUDPNonblockingClient().run(host, port, prefix, threads, requests);
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/implementor/Implementor.java ===
package info.kgeorgiy.ja.gusev.implementor;

import info.kgeorgiy.java.advanced.implementor.Impler;
import info.kgeorgiy.java.advanced.implementor.ImplerException;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Implementation of {@link Impler} interface that generates default implementations
 * of given interfaces or abstract classes.
 *
 * <p>This class generates a Java source file that implements all abstract methods
 * of the specified class or interface. The generated class is named as the original
 * class with {@code Impl} suffix added.</p>
 *
 * <p>Note: The generated implementation may contain unsafe operations (such as 
 * unchecked casts or raw types) and may override deprecated methods from the 
 * implemented interfaces or classes. You may encounter warnings like 
 * "uses unchecked or unsafe operations" or "uses or overrides a deprecated API" 
 * during compilation. These warnings can be checked in more detail by recompiling 
 * with the flag {@code -Xlint:unchecked} for unsafe operations and {@code -Xlint:deprecation} 
 * for deprecated API usage.</p>
 *
 * <p>Example usage:</p>
 * <pre>{@code
 * Path outputPath = Paths.get("output/directory");
 * Class<?> clazz = MyInterface.class;
 * new Implementor().implement(clazz, outputPath);
 * }</pre>
 *
 * <p>This class does not guarantee avoidance of deprecated APIs if they are present 
 * in the implemented interface or class. Additionally, it may use operations that 
 * are flagged as unchecked or unsafe due to type inference or other reasons.</p>
 *
 * @author
 *     Sergei Gusev M3237
 */
public class Implementor implements Impler {

    /**
     * Default constructor.
     */
    public Implementor() {
        // Empty constructor
    }

    /**
     * Generates default implementation of the specified class or interface.
     *
     * <p>Generates a Java source file containing the implementation of the specified
     * class or interface. The generated class will be placed in the specified
     * directory. If the class is not an interface and does not have at least one
     * accessible constructor, an {@link ImplerException} will be thrown.</p>
     *
     * @param clazz the class or interface to implement
     * @param path  the path where the generated implementation should be saved
     * @throws ImplerException if the implementation cannot be generated
     */
    @Override
    public void implement(Class<?> clazz, Path path) throws ImplerException {
        // Check if the class or interface can be implemented
        checkClassValidity(clazz);

        // Build the path for the generated class file
        Path filePath = constructFilePath(clazz, path, ".java");

        // Create parent directories for the file
        createParentDirectories(filePath);

        // Collect all abstract methods that need to be implemented
        Set<Method> abstractMethods = collectAbstractMethods(clazz);

        // Collect necessary imports for the class
        Set<String> imports = collectImports(clazz, abstractMethods);

        try (BufferedWriter writer = Files.newBufferedWriter(filePath)) {
            // Generate class header and imports
            writer.write(generateClassHeader(clazz, imports));

            // If it's a class (not an interface), generate constructors
            if (!clazz.isInterface()) {
                for (Constructor<?> constructor : generateConstructors(clazz)) {
                    writer.write(generateConstructor(constructor));
                }
            }

            // Generate all methods of the class
            for (Method method : abstractMethods) {
                writer.write(generateMethod(method));
            }

            // If it's an annotation, generate the annotationType() method
            if (clazz.isAnnotation()) {
                writer.write(generateAnnotationTypeMethod(clazz));
            }

            // Close the class
            writer.write("}" + System.lineSeparator());
        } catch (IOException e) {
            throw new ImplerException("Error writing to file", e);
        }
    }

    /**
     * Checks if the specified class or interface can be implemented.
     *
     * @param clazz the class or interface to check
     * @throws ImplerException if the class or interface cannot be implemented
     */
    private void checkClassValidity(Class<?> clazz) throws ImplerException {
        int modifiers = clazz.getModifiers();
        if (clazz.isArray() || clazz.isPrimitive() || clazz == Enum.class || Modifier.isFinal(modifiers)) {
            throw new ImplerException("Cannot implement the given class or interface");
        }
        if (Modifier.isPrivate(modifiers)) {
            throw new ImplerException("Cannot implement private class or interface");
        }
        if (clazz == Record.class) {
            throw new ImplerException("Cannot implement Record classes");
        }
    }

    /**
     * Constructs the path for the output file of the generated implementation.
     *
     * @param clazz         the class or interface being implemented
     * @param path          the base output path
     * @param fileExtension the file extension (e.g., ".java")
     * @return the path to the output file
     */
    private Path constructFilePath(Class<?> clazz, Path path, String fileExtension) {
        return path.resolve(clazz.getPackageName().replace('.', File.separatorChar))
                .resolve(clazz.getSimpleName() + "Impl" + fileExtension);
    }

    /**
     * Creates parent directories for the specified path.
     *
     * @param path the path for which to create parent directories
     * @throws ImplerException if the directories cannot be created
     */
    private void createParentDirectories(Path path) throws ImplerException {
        try {
            Files.createDirectories(path.getParent());
        } catch (IOException e) {
            throw new ImplerException("Unable to create directories for output file", e);
        }
    }

    /**
     * Generates accessible constructors for the specified class.
     *
     * @param clazz the class for which to generate constructors
     * @return an array of accessible constructors
     * @throws ImplerException if no accessible constructors are found
     */
    private Constructor<?>[] generateConstructors(Class<?> clazz) throws ImplerException {
        Constructor<?>[] constructors = Arrays.stream(clazz.getDeclaredConstructors())
                .filter(constructor -> !Modifier.isPrivate(constructor.getModifiers()))
                .toArray(Constructor<?>[]::new);

        if (!clazz.isInterface() && constructors.length == 0) {
            throw new ImplerException("No accessible constructors found");
        }

        return constructors;
    }

    /**
     * Collects all abstract methods from the specified class that need to be implemented.
     *
     * @param clazz the class from which to collect methods
     * @return a set of methods to implement
     */
    private Set<Method> collectAbstractMethods(Class<?> clazz) {
        Set<MethodSignature> methodsToImplement = new HashSet<>();
        Set<MethodSignature> implementedMethods = new HashSet<>();
        Map<MethodSignature, Method> methodMap = new HashMap<>();

        collectMethods(clazz, methodsToImplement, implementedMethods, methodMap);

        methodsToImplement.removeAll(implementedMethods);

        return methodsToImplement.stream()
                .map(methodMap::get)
                .collect(Collectors.toSet());
    }

    /**
     * Recursively collects methods from the specified class.
     *
     * @param clazz              the class from which to collect methods
     * @param methodsToImplement set of methods that need to be implemented
     * @param implementedMethods set of methods that are already implemented
     * @param methodMap          a map from method signatures to methods
     */
    private void collectMethods(Class<?> clazz, Set<MethodSignature> methodsToImplement,
                                Set<MethodSignature> implementedMethods, Map<MethodSignature, Method> methodMap) {
        if (clazz == null) {
            return;
        }

        for (Method method : clazz.getDeclaredMethods()) {
            if (Modifier.isPrivate(method.getModifiers())) {
                continue;
            }
            MethodSignature signature = new MethodSignature(method);
            methodMap.putIfAbsent(signature, method);
            if (Modifier.isAbstract(method.getModifiers())) {
                methodsToImplement.add(signature);
            } else {
                implementedMethods.add(signature);
            }
        }

        collectMethods(clazz.getSuperclass(), methodsToImplement, implementedMethods, methodMap);
        for (Class<?> iface : clazz.getInterfaces()) {
            collectMethodsFromInterface(iface, methodsToImplement, implementedMethods, methodMap);
        }
    }

    /**
     * Collects methods from the specified interface.
     *
     * @param iface              the interface from which to collect methods
     * @param methodsToImplement set of methods that need to be implemented
     * @param implementedMethods set of methods that are already implemented
     * @param methodMap          a map from method signatures to methods
     */
    private void collectMethodsFromInterface(Class<?> iface, Set<MethodSignature> methodsToImplement,
                                             Set<MethodSignature> implementedMethods, Map<MethodSignature, Method> methodMap) {
        for (Method method : iface.getDeclaredMethods()) {
            if (Modifier.isPrivate(method.getModifiers())) {
                continue;
            }
            MethodSignature signature = new MethodSignature(method);
            methodMap.putIfAbsent(signature, method);
            if (Modifier.isAbstract(method.getModifiers())) {
                methodsToImplement.add(signature);
            } else {
                implementedMethods.add(signature);
            }
        }

        for (Class<?> superIface : iface.getInterfaces()) {
            collectMethodsFromInterface(superIface, methodsToImplement, implementedMethods, methodMap);
        }
    }

    /**
     * Generates the header of the implementation class, including package declaration and imports.
     *
     * @param clazz   the class being implemented
     * @param imports set of imports required by the class
     * @return a string containing the class header
     */
    private String generateClassHeader(Class<?> clazz, Set<String> imports) {
        StringBuilder header = new StringBuilder();
        String packageName = clazz.getPackageName();
        if (!packageName.isEmpty()) {
            header.append("package ").append(packageName).append(";").append(System.lineSeparator()).append(System.lineSeparator());
        }

        for (String imp : imports) {
            if (!imp.equals(clazz.getCanonicalName())) {
                header.append("import ").append(imp).append(";").append(System.lineSeparator());
            }
        }
        if (!imports.isEmpty()) {
            header.append(System.lineSeparator());
        }

        String extOrImpl = clazz.isInterface() ? "implements" : "extends";
        header.append("public class ").append(clazz.getSimpleName()).append("Impl ")
                .append(extOrImpl).append(" ").append(clazz.getCanonicalName()).append(" {")
                .append(System.lineSeparator());
        return header.toString();
    }

    /**
     * Collects all necessary imports for the class.
     *
     * @param clazz   the class being implemented
     * @param methods the methods to be implemented
     * @return a set of import statements
     */
    private Set<String> collectImports(Class<?> clazz, Set<Method> methods) {
        Set<String> imports = new HashSet<>();

        for (Method method : methods) {
            collectType(imports, method.getReturnType());
            for (Parameter parameter : method.getParameters()) {
                collectType(imports, parameter.getType());
            }
            for (Class<?> exception : method.getExceptionTypes()) {
                collectType(imports, exception);
            }
        }

        return imports;
    }

    /**
     * Collects types for imports.
     *
     * @param imports set of imports to add to
     * @param type    the type to collect
     */
    private void collectType(Set<String> imports, Class<?> type) {
        if (type.isArray()) {
            collectType(imports, type.getComponentType());  // Import base type
        } else if (!type.isPrimitive() && !type.getPackageName().equals("java.lang") && !type.getPackageName().startsWith("java.")) {
            imports.add(type.getCanonicalName());
        }
    }

    /**
     * Generates code for a constructor.
     *
     * @param constructor the constructor to generate
     * @return a string containing the constructor code
     */
    private String generateConstructor(Constructor<?> constructor) {
        List<String> paramNames = new ArrayList<>();
        StringBuilder signature = new StringBuilder();
        signature.append("    ").append(Modifier.toString(constructor.getModifiers() & ~Modifier.ABSTRACT & ~Modifier.TRANSIENT & ~Modifier.NATIVE & ~Modifier.PROTECTED))
                .append(" ").append(constructor.getDeclaringClass().getSimpleName()).append("Impl")
                .append(generateConstructorParameters(constructor, paramNames))
                .append(generateConstructorExceptions(constructor))
                .append(" {").append(System.lineSeparator())
                .append("        super(").append(String.join(", ", paramNames)).append(");").append(System.lineSeparator())
                .append("    }").append(System.lineSeparator());
        return signature.toString();
    }

    /**
     * Generates code for a method.
     *
     * @param method the method to generate
     * @return a string containing the method code
     */
    private String generateMethod(Method method) {
        List<String> paramNames = new ArrayList<>();
        StringBuilder signature = new StringBuilder();
        signature.append("    @Override").append(System.lineSeparator())
                .append("    ").append(Modifier.toString(method.getModifiers() & ~Modifier.ABSTRACT & ~Modifier.TRANSIENT & ~Modifier.NATIVE & Modifier.methodModifiers()))
                .append(" ").append(method.getReturnType().getCanonicalName())
                .append(" ").append(method.getName())
                .append(generateParameters(method, paramNames))
                .append(generateExceptions(method))
                .append(" {").append(System.lineSeparator())
                .append("        ").append(determineReturnValue(method.getReturnType())).append(";").append(System.lineSeparator())
                .append("    }").append(System.lineSeparator());
        return signature.toString();
    }

    /**
     * Generates the {@code annotationType()} method for annotation interfaces.
     *
     * @param clazz the annotation interface
     * @return a string containing the method code
     */
    private String generateAnnotationTypeMethod(Class<?> clazz) {
        if (!hasAnnotationTypeMethod(clazz)) {
            return "    @Override" + System.lineSeparator()
                    + "    public Class<? extends java.lang.annotation.Annotation> annotationType() {" + System.lineSeparator()
                    + "        return this.getClass();" + System.lineSeparator()
                    + "    }" + System.lineSeparator();
        }
        return "";
    }

    /**
     * Checks if the annotation interface has an {@code annotationType()} method.
     *
     * @param clazz the annotation interface
     * @return {@code true} if the method exists, {@code false} otherwise
     */
    private boolean hasAnnotationTypeMethod(Class<?> clazz) {
        try {
            clazz.getMethod("annotationType");
            return true;
        } catch (NoSuchMethodException e) {
            return false;
        }
    }

    /**
     * Generates parameter list for a method.
     *
     * @param method     the method
     * @param paramNames list to store parameter names
     * @return a string containing the parameter list
     */
    private String generateParameters(Method method, List<String> paramNames) {
        Parameter[] parameters = method.getParameters();
        StringBuilder builder = new StringBuilder("(");
        for (int i = 0; i < parameters.length; i++) {
            if (i > 0) {
                builder.append(", ");
            }
            String paramName = "arg" + i;
            builder.append(parameters[i].getType().getCanonicalName()).append(" ").append(paramName);
            paramNames.add(paramName);
        }
        builder.append(")");
        return builder.toString();
    }

    /**
     * Generates parameter list for a constructor.
     *
     * @param constructor the constructor
     * @param paramNames  list to store parameter names
     * @return a string containing the parameter list
     */
    private String generateConstructorParameters(Constructor<?> constructor, List<String> paramNames) {
        Parameter[] parameters = constructor.getParameters();
        StringBuilder builder = new StringBuilder("(");
        for (int i = 0; i < parameters.length; i++) {
            if (i > 0) {
                builder.append(", ");
            }
            String paramName = "arg" + i;
            builder.append(parameters[i].getType().getCanonicalName()).append(" ").append(paramName);
            paramNames.add(paramName);
        }
        builder.append(")");
        return builder.toString();
    }

    /**
     * Generates exceptions list for a method.
     *
     * @param method the method
     * @return a string containing the exceptions list
     */
    private String generateExceptions(Method method) {
        Class<?>[] exceptions = method.getExceptionTypes();
        if (exceptions.length == 0) {
            return "";
        }
        return " throws " + Arrays.stream(exceptions)
                .map(Class::getCanonicalName)
                .collect(Collectors.joining(", "));
    }

    /**
     * Generates exceptions list for a constructor.
     *
     * @param constructor the constructor
     * @return a string containing the exceptions list
     */
    private String generateConstructorExceptions(Constructor<?> constructor) {
        Class<?>[] exceptions = constructor.getExceptionTypes();
        if (exceptions.length == 0) {
            return "";
        }
        return " throws " + Arrays.stream(exceptions)
                .map(Class::getCanonicalName)
                .collect(Collectors.joining(", "));
    }

    /**
     * Determines the default return value for the specified return type.
     *
     * @param returnType the return type
     * @return a string containing the return statement
     */
    private String determineReturnValue(Class<?> returnType) {
        if (returnType.equals(void.class)) {
            return "";
        } else if (returnType.equals(boolean.class)) {
            return "return false";
        } else if (returnType.isPrimitive()) {
            return "return 0";
        }
        return "return null";
    }

    /**
     * Helper class representing the signature of a method for comparison purposes.
     */
    private static class MethodSignature {
        /** The name of the method */
        private final String name;
        /** The parameter types of the method */
        private final Class<?>[] parameterTypes;

        /**
         * Constructs a new {@code MethodSignature} based on the specified method.
         *
         * @param method the method from which to create the signature
         */
        public MethodSignature(Method method) {
            this.name = method.getName();
            this.parameterTypes = method.getParameterTypes();
        }

        /**
         * Checks if this {@code MethodSignature} is equal to another object.
         *
         * @param o the object to compare
         * @return {@code true} if equal, {@code false} otherwise
         */
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof MethodSignature)) return false;
            MethodSignature that = (MethodSignature) o;
            return name.equals(that.name) && Arrays.equals(parameterTypes, that.parameterTypes);
        }

        /**
         * Computes the hash code for this {@code MethodSignature}.
         *
         * @return the hash code
         */
        @Override
        public int hashCode() {
            int result = name.hashCode();
            result = 31 * result + Arrays.hashCode(parameterTypes);
            return result;
        }
    }
}

=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/iterative/IterativeParallelism.java ===
package info.kgeorgiy.ja.gusev.iterative;

import info.kgeorgiy.java.advanced.iterative.*;

import java.util.*;
import java.util.function.*;

public class IterativeParallelism implements NewListIP {

    private <T> List<List<? extends T>> split(int threads, List<? extends T> values) {
        int n = Math.min(threads, values.size());
        List<List<? extends T>> result = new ArrayList<>(n);
        int chunkSize = values.size() / n;
        int remainder = values.size() % n;
        int start = 0;
        for (int i = 0; i < n; i++) {
            int end = start + chunkSize + (i < remainder ? 1 : 0);
            result.add(values.subList(start, end));
            start = end;
        }
        return result;
    }

    private static class StepList<T> extends AbstractList<T> {
        private final List<? extends T> list;
        private final int step;
        private final int size;

        public StepList(List<? extends T> list, int step) {
            this.list = list;
            this.step = step;
            this.size = (list.size() + step - 1) / step;
        }

        @Override
        public T get(int index) {
            int actualIndex = index * step;
            if (actualIndex >= list.size()) {
                throw new IndexOutOfBoundsException();
            }
            return list.get(actualIndex);
        }

        @Override
        public int size() {
            return size;
        }
    }

    @Override
    public <T> T maximum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator) throws InterruptedException {
        return maximum(threads, values, comparator, 1);
    }

    @Override
    public <T> T maximum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        if (stepValues.isEmpty()) {
            throw new NoSuchElementException("List is empty");
        }
        List<List<? extends T>> chunks = split(threads, stepValues);
        int n = chunks.size();
        @SuppressWarnings("unchecked")
        T[] maxValues = (T[]) new Object[n];
        Thread[] threadArray = new Thread[n];
        for (int i = 0; i < n; i++) {
            final List<? extends T> chunk = chunks.get(i);
            final int index = i;
            threadArray[i] = new Thread(() -> {
                T max = Collections.max(chunk, comparator);
                maxValues[index] = max;
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        return Collections.max(Arrays.asList(maxValues), comparator);
    }

    @Override
    public <T> T minimum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator) throws InterruptedException {
        return minimum(threads, values, comparator, 1);
    }

    @Override
    public <T> T minimum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        if (stepValues.isEmpty()) {
            throw new NoSuchElementException("List is empty");
        }
        List<List<? extends T>> chunks = split(threads, stepValues);
        int n = chunks.size();
        @SuppressWarnings("unchecked")
        T[] minValues = (T[]) new Object[n];
        Thread[] threadArray = new Thread[n];
        for (int i = 0; i < n; i++) {
            final List<? extends T> chunk = chunks.get(i);
            final int index = i;
            threadArray[i] = new Thread(() -> {
                T min = Collections.min(chunk, comparator);
                minValues[index] = min;
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        return Collections.min(Arrays.asList(minValues), comparator);
    }

    @Override
    public <T> boolean all(int threads, List<? extends T> values,
                           Predicate<? super T> predicate) throws InterruptedException {
        return all(threads, values, predicate, 1);
    }

    @Override
    public <T> boolean all(int threads, List<? extends T> values,
                           Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        boolean[] result = {true};
        Thread[] threadArray = new Thread[chunks.size()];
        for (int i = 0; i < chunks.size(); i++) {
            final List<? extends T> chunk = chunks.get(i);
            threadArray[i] = new Thread(() -> {
                for (T value : chunk) {
                    synchronized (result) {
                        if (!result[0]) {
                            return;
                        }
                    }
                    if (!predicate.test(value)) {
                        synchronized (result) {
                            result[0] = false;
                        }
                        return;
                    }
                }
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        return result[0];
    }

    @Override
    public <T> boolean any(int threads, List<? extends T> values,
                           Predicate<? super T> predicate) throws InterruptedException {
        return any(threads, values, predicate, 1);
    }

    @Override
    public <T> boolean any(int threads, List<? extends T> values,
                           Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        boolean[] result = {false};
        Thread[] threadArray = new Thread[chunks.size()];
        for (int i = 0; i < chunks.size(); i++) {
            final List<? extends T> chunk = chunks.get(i);
            threadArray[i] = new Thread(() -> {
                for (T value : chunk) {
                    synchronized (result) {
                        if (result[0]) {
                            return;
                        }
                    }
                    if (predicate.test(value)) {
                        synchronized (result) {
                            result[0] = true;
                        }
                        return;
                    }
                }
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        return result[0];
    }

    @Override
    public <T> int count(int threads, List<? extends T> values,
                         Predicate<? super T> predicate) throws InterruptedException {
        return count(threads, values, predicate, 1);
    }

    @Override
    public <T> int count(int threads, List<? extends T> values,
                         Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        int n = chunks.size();
        int[] counts = new int[n];
        Thread[] threadArray = new Thread[n];
        for (int i = 0; i < n; i++) {
            final List<? extends T> chunk = chunks.get(i);
            final int index = i;
            threadArray[i] = new Thread(() -> {
                int count = 0;
                for (T value : chunk) {
                    if (predicate.test(value)) {
                        count++;
                    }
                }
                counts[index] = count;
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        int total = 0;
        for (int count : counts) {
            total += count;
        }
        return total;
    }

    @Override
    public String join(int threads, List<?> values) throws InterruptedException {
        return join(threads, values, 1);
    }

    @Override
    public String join(int threads, List<?> values, int step) throws InterruptedException {
        List<?> stepValues = new StepList<>(values, step);
        List<List<?>> chunks = split(threads, stepValues);
        int n = chunks.size();
        String[] results = new String[n];
        Thread[] threadArray = new Thread[n];
        for (int i = 0; i < n; i++) {
            final List<?> chunk = chunks.get(i);
            final int index = i;
            threadArray[i] = new Thread(() -> {
                StringBuilder sb = new StringBuilder();
                for (Object value : chunk) {
                    sb.append(value.toString());
                }
                results[index] = sb.toString();
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        StringBuilder finalResult = new StringBuilder();
        for (String result : results) {
            finalResult.append(result);
        }
        return finalResult.toString();
    }

    @Override
    public <T> List<T> filter(int threads, List<? extends T> values,
                              Predicate<? super T> predicate) throws InterruptedException {
        return filter(threads, values, predicate, 1);
    }

    @Override
    public <T> List<T> filter(int threads, List<? extends T> values,
                              Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        int n = chunks.size();
        List<List<T>> results = new ArrayList<>(Collections.nCopies(n, null));
        Thread[] threadArray = new Thread[n];
        for (int i = 0; i < n; i++) {
            final List<? extends T> chunk = chunks.get(i);
            final int index = i;
            threadArray[i] = new Thread(() -> {
                List<T> result = new ArrayList<>();
                for (T value : chunk) {
                    if (predicate.test(value)) {
                        result.add(value);
                    }
                }
                results.set(index, result);
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        List<T> finalResult = new ArrayList<>();
        for (List<T> result : results) {
            finalResult.addAll(result);
        }
        return finalResult;
    }

    @Override
    public <T, U> List<U> map(int threads, List<? extends T> values,
                              Function<? super T, ? extends U> function) throws InterruptedException {
        return map(threads, values, function, 1);
    }

    @Override
    public <T, U> List<U> map(int threads, List<? extends T> values,
                              Function<? super T, ? extends U> function, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        int n = chunks.size();
        List<List<U>> results = new ArrayList<>(Collections.nCopies(n, null));
        Thread[] threadArray = new Thread[n];
        for (int i = 0; i < n; i++) {
            final List<? extends T> chunk = chunks.get(i);
            final int index = i;
            threadArray[i] = new Thread(() -> {
                List<U> result = new ArrayList<>(chunk.size());
                for (T value : chunk) {
                    result.add(function.apply(value));
                }
                results.set(index, result);
            });
            threadArray[i].start();
        }
        for (Thread thread : threadArray) {
            thread.join();
        }
        List<U> finalResult = new ArrayList<>();
        for (List<U> result : results) {
            finalResult.addAll(result);
        }
        return finalResult;
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/jarimplementor/JarImplementor.java ===
package info.kgeorgiy.ja.gusev.jarimplementor;

import info.kgeorgiy.java.advanced.implementor.Impler;
import info.kgeorgiy.java.advanced.implementor.ImplerException;
import info.kgeorgiy.java.advanced.implementor.JarImpler;

import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.io.File;
import java.lang.reflect.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.jar.*;
import java.util.stream.Collectors;

/**
 * Implementation of {@link Impler} and {@link JarImpler} interfaces that allows generating default implementations
 * of specified interfaces or abstract classes and packaging them into a JAR file.
 *
 * <p>This class generates a Java source file that implements all abstract methods
 * of the specified class or interface. The generated class is named as the original
 * class with {@code Impl} suffix added. It also provides functionality to compile
 * the generated source file and package it into a JAR file.</p>
 *
 * <p>Note: The generated implementation may use or override deprecated methods from 
 * the implemented interfaces or classes. You may encounter warnings like 
 * "uses or overrides a deprecated API" during compilation. These warnings can be 
 * examined in more detail by recompiling with the flag {@code -Xlint:deprecation}.</p>
 *
 * <p>Example usage:</p>
 * <pre>{@code
 * Path outputPath = Paths.get("output/directory");
 * Class<?> clazz = MyInterface.class;
 * new JarImplementor().implement(clazz, outputPath);
 *
 * Path jarFile = Paths.get("output/myInterfaceImpl.jar");
 * new JarImplementor().implementJar(clazz, jarFile);
 * }</pre>
 *
 * <p>This class does not guarantee avoidance of deprecated APIs if they are present 
 * in the implemented interface or class. The usage of deprecated methods is inherent 
 * to the underlying APIs being implemented.</p>
 *
 * @author
 *     Sergei Gusev M3237
 */
public class JarImplementor implements Impler, JarImpler {

    /**
     * Default constructor.
     */
    public JarImplementor() {
        // Empty constructor
    }


    /**
     * System-dependent line separator.
     */
    private static final String LINE_SEPARATOR = System.lineSeparator();
    /**
     * Standard indentation (4 spaces) used in generated code.
     */
    private static final String INDENT = "    ";

    /**
     * Entry point of the program.
     *
     * <p>Usage:</p>
     * <ul>
     *     <li>{@code JarImplementor -jar <class name> <jar path>} - Generates implementation and packages it into a JAR file.</li>
     * </ul>
     *
     * @param args command line arguments
     */
    public static void main(String[] args) {
        if (args == null || args.length != 3 || args[0] == null || args[1] == null || args[2] == null) {
            System.err.println("Usage: JarImplementor -jar <class name> <jar path>");
            return;
        }

        JarImplementor implementor = new JarImplementor();

        try {
            if ("-jar".equals(args[0])) {
                Class<?> token = Class.forName(args[1]);
                Path jarFile = Paths.get(args[2]);
                implementor.implementJar(token, jarFile);
            } else {
                System.err.println("Invalid arguments");
            }
        } catch (ClassNotFoundException e) {
            System.err.println("Class not found: " + e.getMessage());
        } catch (ImplerException e) {
            System.err.println("Implementation error: " + e.getMessage());
        }
    }

    /**
     * Converts the given string to Unicode-escaped representation.
     *
     * @param str the string to escape
     * @return the Unicode-escaped string
     */
    private static String escapeUnicode(String str) {
        StringBuilder sb = new StringBuilder();
        for (char c : str.toCharArray()) {
            if (c >= 128) {
                sb.append(String.format("\\u%04X", (int) c));
            } else if (c == '\\') {
                sb.append("\\\\");
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Returns the default value for the specified type.
     *
     * @param type the type for which to get the default value
     * @return the default value as a string
     */
    private static String getDefaultValue(Class<?> type) {
        if (!type.isPrimitive()) {
            return "null";
        } else if (type.equals(boolean.class)) {
            return "false";
        } else if (type.equals(void.class)) {
            return "";
        } else if (type.equals(char.class)) {
            return "'\\0'";
        } else {
            return "0";
        }
    }

    /**
     * Generates default implementation of the specified class or interface.
     *
     * <p>Generates a Java source file containing the implementation of the specified
     * class or interface. The generated class will be placed in the specified
     * directory. If the class is not an interface and does not have at least one
     * accessible constructor, an {@link ImplerException} will be thrown.</p>
     *
     * @param token the class or interface to implement
     * @param root  the root directory where the generated implementation should be saved
     * @throws ImplerException if the implementation cannot be generated
     */
    @Override
    public void implement(Class<?> token, Path root) throws ImplerException {
        // Validate input parameters
        if (token == null || root == null) {
            throw new ImplerException("Token or root is null");
        }
        validateToken(token);

        // Build the path for the generated class file
        Path filePath = getFilePath(token, root, ".java");

        // Create parent directories for the file
        createParentDirectories(filePath);

        // Generate the code and write to file
        try (Writer writer = new BufferedWriter(new OutputStreamWriter(
                Files.newOutputStream(filePath), StandardCharsets.UTF_8))) {
            writer.write(generateCode(token));
        } catch (IOException e) {
            throw new ImplerException("Cannot write to file", e);
        }
    }

    /**
     * Generates default implementation of the specified class or interface and packages it into a JAR file.
     *
     * @param token   the class or interface to implement
     * @param jarFile the path to the output JAR file
     * @throws ImplerException if the implementation cannot be generated
     */
    @Override
    public void implementJar(Class<?> token, Path jarFile) throws ImplerException {
        // Validate input parameters
        if (token == null || jarFile == null) {
            throw new ImplerException("Token or jarFile is null");
        }
        Path tempDir;
        try {
            tempDir = Files.createTempDirectory("temp");
        } catch (IOException e) {
            throw new ImplerException("Cannot create temporary directory", e);
        }

        try {
            implement(token, tempDir);
            compile(token, tempDir);
            createJar(token, tempDir, jarFile);
        } finally {
            // Clean up temporary files
            try {
                Files.walk(tempDir)
                        .sorted(Comparator.reverseOrder())
                        .map(Path::toFile)
                        .forEach(File::delete);
            } catch (IOException ignored) {
            }
        }
    }

    /**
     * Validates the class or interface to be implemented.
     *
     * @param token the class or interface to validate
     * @throws ImplerException if the token is invalid for implementation
     */
    private void validateToken(Class<?> token) throws ImplerException {
        int modifiers = token.getModifiers();
        if (Modifier.isFinal(modifiers)) {
            throw new ImplerException("Cannot extend final class");
        }
        if (token.isPrimitive() || token == Enum.class || token.isArray()) {
            throw new ImplerException("Invalid token");
        }
        if (Modifier.isPrivate(modifiers)) {
            throw new ImplerException("Cannot implement private class");
        }
        if (token == Record.class) {
            throw new ImplerException("Cannot implement Record classes");
        }
    }

    /**
     * Constructs the path for the output file of the generated implementation.
     *
     * @param token         the class or interface being implemented
     * @param root          the base output path
     * @param fileExtension the file extension (e.g., ".java")
     * @return the path to the output file
     */
    private Path getFilePath(Class<?> token, Path root, String fileExtension) {
        return root.resolve(token.getPackageName().replace('.', File.separatorChar))
                .resolve(token.getSimpleName() + "Impl" + fileExtension);
    }

    /**
     * Creates parent directories for the specified path.
     *
     * @param path the path for which to create parent directories
     * @throws ImplerException if the directories cannot be created
     */
    private void createParentDirectories(Path path) throws ImplerException {
        try {
            Files.createDirectories(path.getParent());
        } catch (IOException e) {
            throw new ImplerException("Cannot create directories", e);
        }
    }

    /**
     * Generates the code for the implementation of the specified class or interface.
     *
     * @param token the class or interface to implement
     * @return the generated code as a string
     * @throws ImplerException if code generation fails
     */
    private String generateCode(Class<?> token) throws ImplerException {
        StringBuilder sb = new StringBuilder();

        String packageName = token.getPackageName();
        if (!packageName.isEmpty()) {
            sb.append("package ").append(escapeUnicode(packageName)).append(";").append(LINE_SEPARATOR).append(LINE_SEPARATOR);
        }

        String className = escapeUnicode(token.getSimpleName()) + "Impl";
        String classDeclaration = "public class " + className + " ";

        if (token.isInterface()) {
            classDeclaration += "implements ";
        } else {
            classDeclaration += "extends ";
        }
        classDeclaration += escapeUnicode(token.getCanonicalName()) + " {" + LINE_SEPARATOR;

        sb.append(classDeclaration);

        if (!token.isInterface()) {
            sb.append(generateConstructors(token));
        }

        sb.append(generateMethods(token));

        sb.append("}").append(LINE_SEPARATOR);

        return sb.toString();
    }

    /**
     * Generates constructors for the implementation class.
     *
     * @param token the class being implemented
     * @return the generated constructors as a string
     * @throws ImplerException if no accessible constructors are found
     */
    private String generateConstructors(Class<?> token) throws ImplerException {
        Constructor<?>[] constructors = token.getDeclaredConstructors();
        List<Constructor<?>> publicConstructors = Arrays.stream(constructors)
                .filter(c -> !Modifier.isPrivate(c.getModifiers()))
                .collect(Collectors.toList());

        if (!token.isInterface() && publicConstructors.isEmpty()) {
            throw new ImplerException("No accessible constructors found");
        }

        StringBuilder sb = new StringBuilder();

        for (Constructor<?> constructor : publicConstructors) {
            sb.append(INDENT);
            int modifiers = constructor.getModifiers() & ~Modifier.ABSTRACT & ~Modifier.TRANSIENT & ~Modifier.NATIVE & ~Modifier.SYNCHRONIZED & ~Modifier.PROTECTED;
            sb.append(Modifier.toString(modifiers));
            if (modifiers != 0) {
                sb.append(" ");
            }
            sb.append(escapeUnicode(token.getSimpleName())).append("Impl(");

            Parameter[] parameters = constructor.getParameters();
            String params = Arrays.stream(parameters)
                    .map(p -> escapeUnicode(getType(p.getParameterizedType())) + " " + escapeUnicode(p.getName()))
                    .collect(Collectors.joining(", "));
            sb.append(params).append(")");

            Class<?>[] exceptions = constructor.getExceptionTypes();
            if (exceptions.length > 0) {
                sb.append(" throws ").append(Arrays.stream(exceptions)
                        .map(c -> escapeUnicode(c.getCanonicalName()))
                        .collect(Collectors.joining(", ")));
            }

            sb.append(" {").append(LINE_SEPARATOR);
            sb.append(INDENT).append(INDENT).append("super(");
            String args = Arrays.stream(parameters)
                    .map(p -> escapeUnicode(p.getName()))
                    .collect(Collectors.joining(", "));
            sb.append(args).append(");").append(LINE_SEPARATOR);

            sb.append(INDENT).append("}").append(LINE_SEPARATOR).append(LINE_SEPARATOR);
        }

        return sb.toString();
    }

    /**
     * Generates methods for the implementation class.
     *
     * @param token the class or interface being implemented
     * @return the generated methods as a string
     */
    private String generateMethods(Class<?> token) {
        Map<MethodSignature, Method> methods = new LinkedHashMap<>();
        Set<MethodSignature> implementedMethods = new HashSet<>();
        collectMethods(token, methods, implementedMethods);

        StringBuilder sb = new StringBuilder();
        for (Method method : methods.values()) {
            if (Modifier.isAbstract(method.getModifiers()) && !Modifier.isFinal(method.getModifiers())) {
                sb.append(generateMethod(method, token));
            }
        }
        return sb.toString();
    }

    /**
     * Collects methods that need to be implemented from the specified class or interface.
     *
     * @param token              the class or interface to collect methods from
     * @param abstractMethods    map to collect abstract methods into
     * @param implementedMethods set to collect implemented methods into
     */
    private void collectMethods(Class<?> token, Map<MethodSignature, Method> abstractMethods, Set<MethodSignature> implementedMethods) {
        if (token == null) {
            return;
        }

        for (Method method : token.getDeclaredMethods()) {
            int modifiers = method.getModifiers();
            MethodSignature signature = new MethodSignature(method);
            if (Modifier.isAbstract(modifiers)) {
                if (!Modifier.isPrivate(modifiers) && !Modifier.isFinal(modifiers)) {
                    if (!implementedMethods.contains(signature)) {
                        abstractMethods.putIfAbsent(signature, method);
                    }
                }
            } else {
                implementedMethods.add(signature);
                abstractMethods.remove(signature);
            }
        }

        for (Class<?> iface : token.getInterfaces()) {
            collectMethods(iface, abstractMethods, implementedMethods);
        }

        collectMethods(token.getSuperclass(), abstractMethods, implementedMethods);
    }

    /**
     * Generates code for a method.
     *
     * @param method the method to generate
     * @param token  the class or interface being implemented
     * @return a string containing the method code
     */
    private String generateMethod(Method method, Class<?> token) {
        StringBuilder sb = new StringBuilder();
        sb.append(INDENT).append("@Override").append(LINE_SEPARATOR);

        int modifiers = method.getModifiers() & ~Modifier.ABSTRACT & ~Modifier.TRANSIENT & ~Modifier.NATIVE & ~Modifier.SYNCHRONIZED & ~Modifier.STRICT & Modifier.methodModifiers();
        sb.append(INDENT).append(Modifier.toString(modifiers));
        if (modifiers != 0) {
            sb.append(" ");
        }

        TypeVariable<Method>[] typeParameters = method.getTypeParameters();
        if (typeParameters.length > 0) {
            sb.append("<");
            sb.append(Arrays.stream(typeParameters)
                    .map(this::getTypeVariable)
                    .map(JarImplementor::escapeUnicode)
                    .collect(Collectors.joining(", ")));
            sb.append("> ");
        }

        sb.append(escapeUnicode(getType(method.getGenericReturnType()))).append(" ");
        sb.append(escapeUnicode(method.getName())).append("(");

        Parameter[] parameters = method.getParameters();
        String params = Arrays.stream(parameters)
                .map(p -> escapeUnicode(getType(p.getParameterizedType())) + " " + escapeUnicode(p.getName()))
                .collect(Collectors.joining(", "));
        sb.append(params).append(")");

        Set<String> allowedExceptions = getAllowedExceptions(method, token);
        if (!allowedExceptions.isEmpty()) {
            sb.append(" throws ").append(allowedExceptions.stream()
                    .map(JarImplementor::escapeUnicode)
                    .collect(Collectors.joining(", ")));
        }

        sb.append(" {").append(LINE_SEPARATOR);
        sb.append(INDENT).append(INDENT);
        if (method.getReturnType() != void.class) {
            sb.append("return ").append(getDefaultValue(method.getReturnType())).append(";");
        }
        sb.append(LINE_SEPARATOR).append(INDENT).append("}").append(LINE_SEPARATOR).append(LINE_SEPARATOR);
        return sb.toString();
    }

    /**
     * Determines the allowed exceptions for a method based on overridden methods.
     *
     * @param method the method to analyze
     * @param token  the class or interface being implemented
     * @return a set of allowed exception types
     */
    private Set<String> getAllowedExceptions(Method method, Class<?> token) {
        Set<String> allowedExceptions = new HashSet<>();
        Set<Class<?>> exceptionTypes = new HashSet<>();

        Method overriddenMethod = findOverriddenMethod(token.getSuperclass(), method);
        if (overriddenMethod != null) {
            exceptionTypes.addAll(Arrays.asList(overriddenMethod.getExceptionTypes()));
        }

        for (Class<?> iface : token.getInterfaces()) {
            Method interfaceMethod = findOverriddenMethod(iface, method);
            if (interfaceMethod != null) {
                exceptionTypes.addAll(Arrays.asList(interfaceMethod.getExceptionTypes()));
            }
        }

        for (Class<?> exception : method.getExceptionTypes()) {
            if (exceptionTypes.contains(exception)) {
                allowedExceptions.add(getType(exception));
            }
        }

        return allowedExceptions;
    }

    /**
     * Finds the overridden method in the superclass or interfaces.
     *
     * @param token  the class to search in
     * @param method the method to find
     * @return the overridden method if found, or {@code null}
     */
    private Method findOverriddenMethod(Class<?> token, Method method) {
        if (token == null) {
            return null;
        }
        try {
            return token.getDeclaredMethod(method.getName(), method.getParameterTypes());
        } catch (NoSuchMethodException e) {
            Method m = findOverriddenMethod(token.getSuperclass(), method);
            if (m != null) {
                return m;
            }
            for (Class<?> iface : token.getInterfaces()) {
                m = findOverriddenMethod(iface, method);
                if (m != null) {
                    return m;
                }
            }
            return null;
        }
    }

    /**
     * Returns the string representation of a type.
     *
     * @param type the type to represent
     * @return the string representation of the type
     */
    private String getType(Type type) {
        if (type instanceof Class) {
            return ((Class<?>) type).getCanonicalName();
        } else if (type instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) type;
            StringBuilder sb = new StringBuilder();
            sb.append(getType(pt.getRawType()));
            Type[] args = pt.getActualTypeArguments();
            if (args.length > 0) {
                sb.append("<").append(Arrays.stream(args).map(this::getType).collect(Collectors.joining(", "))).append(">");
            }
            return sb.toString();
        } else if (type instanceof TypeVariable) {
            return ((TypeVariable<?>) type).getName();
        } else if (type instanceof WildcardType) {
            WildcardType wt = (WildcardType) type;
            StringBuilder sb = new StringBuilder("?");
            Type[] upperBounds = wt.getUpperBounds();
            if (upperBounds.length > 0 && upperBounds[0] != Object.class) {
                sb.append(" extends ").append(getType(upperBounds[0]));
            }
            Type[] lowerBounds = wt.getLowerBounds();
            if (lowerBounds.length > 0) {
                sb.append(" super ").append(getType(lowerBounds[0]));
            }
            return sb.toString();
        } else if (type instanceof GenericArrayType) {
            return getType(((GenericArrayType) type).getGenericComponentType()) + "[]";
        } else {
            return type.toString();
        }
    }

    /**
     * Returns the string representation of a type variable.
     *
     * @param typeVariable the type variable to represent
     * @return the string representation of the type variable
     */
    private String getTypeVariable(TypeVariable<?> typeVariable) {
        StringBuilder sb = new StringBuilder();
        sb.append(typeVariable.getName());
        Type[] bounds = typeVariable.getBounds();
        if (bounds.length > 0 && !(bounds.length == 1 && bounds[0].equals(Object.class))) {
            sb.append(" extends ");
            sb.append(Arrays.stream(bounds)
                    .map(this::getType)
                    .collect(Collectors.joining(" & ")));
        }
        return sb.toString();
    }

    /**
     * Compiles the generated source code.
     *
     * @param token   the class or interface being implemented
     * @param tempDir the temporary directory containing the source code
     * @throws ImplerException if compilation fails
     */
    private void compile(Class<?> token, Path tempDir) throws ImplerException {
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        if (compiler == null) {
            throw new ImplerException("No Java compiler found");
        }

        String classPath = tempDir.toString() + File.pathSeparator + System.getProperty("java.class.path");

        Path filePath = tempDir.resolve(token.getPackageName().replace('.', File.separatorChar))
                .resolve(token.getSimpleName() + "Impl.java");

        List<String> args = new ArrayList<>();
        args.add(filePath.toString());
        args.add("-cp");
        args.add(classPath);
        args.add("-encoding");
        args.add("UTF-8");

        int exitCode = compiler.run(null, null, null, args.toArray(new String[0]));

        if (exitCode != 0) {
            throw new ImplerException("Compilation failed");
        }
    }

    /**
     * Creates a JAR file containing the compiled implementation.
     *
     * @param token   the class or interface being implemented
     * @param tempDir the temporary directory containing the compiled class
     * @param jarFile the path to the output JAR file
     * @throws ImplerException if an error occurs during JAR creation
     */
    private void createJar(Class<?> token, Path tempDir, Path jarFile) throws ImplerException {
        Manifest manifest = new Manifest();
        manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");

        Path classFile = tempDir.resolve(token.getPackageName().replace('.', File.separatorChar))
                .resolve(token.getSimpleName() + "Impl.class");

        String entryName = token.getPackageName().replace('.', '/') + "/" + token.getSimpleName() + "Impl.class";

        try (JarOutputStream jarOut = new JarOutputStream(Files.newOutputStream(jarFile), manifest)) {
            jarOut.putNextEntry(new JarEntry(entryName));
            Files.copy(classFile, jarOut);
            jarOut.closeEntry();
        } catch (IOException e) {
            throw new ImplerException("Cannot create JAR file", e);
        }
    }

    /**
     * Helper class representing the signature of a method for comparison purposes.
     */
    private static class MethodSignature {
        /**
         * The name of the method.
         */
        private final String name;
        /**
         * The list of parameter types of the method.
         */
        private final List<Class<?>> parameterTypes;
        /**
         * The list of type parameter names of the method.
         */
        private final List<String> typeParameters;

        /**
         * Constructs a new {@code MethodSignature} based on the specified method.
         *
         * @param method the method from which to create the signature
         */
        public MethodSignature(Method method) {
            this.name = method.getName();
            this.parameterTypes = Arrays.asList(method.getParameterTypes());
            this.typeParameters = Arrays.stream(method.getTypeParameters())
                    .map(TypeVariable::getName)
                    .collect(Collectors.toList());
        }

        /**
         * Checks if this {@code MethodSignature} is equal to another object.
         *
         * @param obj the object to compare
         * @return {@code true} if equal, {@code false} otherwise
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (!(obj instanceof MethodSignature)) return false;
            MethodSignature other = (MethodSignature) obj;
            return name.equals(other.name)
                    && parameterTypes.equals(other.parameterTypes)
                    && typeParameters.equals(other.typeParameters);
        }

        /**
         * Computes the hash code for this {@code MethodSignature}.
         *
         * @return the hash code
         */
        @Override
        public int hashCode() {
            return Objects.hash(name, parameterTypes, typeParameters);
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/mapper/IterativeParallelism.java ===
package info.kgeorgiy.ja.gusev.mapper;

import info.kgeorgiy.java.advanced.iterative.*;
import info.kgeorgiy.java.advanced.mapper.ParallelMapper;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

public class IterativeParallelism implements NewListIP {

    private final ParallelMapper mapper;

    public IterativeParallelism() {
        this.mapper = null;
    }

    public IterativeParallelism(ParallelMapper mapper) {
        this.mapper = mapper;
    }

    private <T> List<List<? extends T>> split(int threads, List<? extends T> values) {
        int n = Math.min(threads, values.size());
        List<List<? extends T>> result = new ArrayList<>(n);
        int chunkSize = values.size() / n;
        int remainder = values.size() % n;
        int start = 0;
        for (int i = 0; i < n; i++) {
            int end = start + chunkSize + (i < remainder ? 1 : 0);
            result.add(values.subList(start, end));
            start = end;
        }
        return result;
    }

    private static class StepList<T> extends AbstractList<T> {
        private final List<? extends T> list;
        private final int step;
        private final int size;

        public StepList(List<? extends T> list, int step) {
            this.list = list;
            this.step = step;
            this.size = (list.size() + step - 1) / step;
        }

        @Override
        public T get(int index) {
            int actualIndex = index * step;
            if (actualIndex >= list.size()) {
                throw new IndexOutOfBoundsException();
            }
            return list.get(actualIndex);
        }

        @Override
        public int size() {
            return size;
        }
    }

    @FunctionalInterface
    public interface Task<T> {
        T call() throws Exception;
    }

    private <T> List<T> executeTasks(List<Task<T>> tasks) throws InterruptedException {
        List<Thread> threads = new ArrayList<>();
        List<T> results = new ArrayList<>(Collections.nCopies(tasks.size(), null));
        for (int i = 0; i < tasks.size(); i++) {
            final int index = i;
            Thread thread = new Thread(() -> {
                try {
                    results.set(index, tasks.get(index).call());
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            });
            threads.add(thread);
            thread.start();
        }
        for (Thread thread : threads) {
            thread.join();
        }
        return results;
    }

    @Override
    public <T> T maximum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator) throws InterruptedException {
        return maximum(threads, values, comparator, 1);
    }

    @Override
    public <T> T maximum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        if (stepValues.isEmpty()) {
            throw new NoSuchElementException("List is empty");
        }
        List<List<? extends T>> chunks = split(threads, stepValues);
        List<T> maxValues;
        if (mapper != null) {
            maxValues = mapper.map(
                    chunk -> Collections.max(chunk, comparator),
                    chunks
            );
        } else {
            List<Task<T>> tasks = chunks.stream()
                    .map(chunk -> (Task<T>) () -> Collections.max(chunk, comparator))
                    .collect(Collectors.toList());
            maxValues = executeTasks(tasks);
        }
        return Collections.max(maxValues, comparator);
    }

    @Override
    public <T> T minimum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator) throws InterruptedException {
        return minimum(threads, values, comparator, 1);
    }

    @Override
    public <T> T minimum(int threads, List<? extends T> values,
                         Comparator<? super T> comparator, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        if (stepValues.isEmpty()) {
            throw new NoSuchElementException("List is empty");
        }
        List<List<? extends T>> chunks = split(threads, stepValues);
        List<T> minValues;
        if (mapper != null) {
            minValues = mapper.map(
                    chunk -> Collections.min(chunk, comparator),
                    chunks
            );
        } else {
            List<Task<T>> tasks = chunks.stream()
                    .map(chunk -> (Task<T>) () -> Collections.min(chunk, comparator))
                    .collect(Collectors.toList());
            minValues = executeTasks(tasks);
        }
        return Collections.min(minValues, comparator);
    }

    @Override
    public <T> boolean all(int threads, List<? extends T> values,
                           Predicate<? super T> predicate) throws InterruptedException {
        return all(threads, values, predicate, 1);
    }

    @Override
    public <T> boolean all(int threads, List<? extends T> values,
                           Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        if (mapper != null) {
            List<Boolean> results = mapper.map(
                    chunk -> chunk.stream().allMatch(predicate),
                    chunks
            );
            return results.stream().allMatch(Boolean::booleanValue);
        } else {
            List<Task<Boolean>> tasks = chunks.stream()
                    .map(chunk -> (Task<Boolean>) () -> chunk.stream().allMatch(predicate))
                    .collect(Collectors.toList());
            List<Boolean> results = executeTasks(tasks);
            return results.stream().allMatch(Boolean::booleanValue);
        }
    }

    @Override
    public <T> boolean any(int threads, List<? extends T> values,
                           Predicate<? super T> predicate) throws InterruptedException {
        return any(threads, values, predicate, 1);
    }

    @Override
    public <T> boolean any(int threads, List<? extends T> values,
                           Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        if (mapper != null) {
            List<Boolean> results = mapper.map(
                    chunk -> chunk.stream().anyMatch(predicate),
                    chunks
            );
            return results.stream().anyMatch(Boolean::booleanValue);
        } else {
            List<Task<Boolean>> tasks = chunks.stream()
                    .map(chunk -> (Task<Boolean>) () -> chunk.stream().anyMatch(predicate))
                    .collect(Collectors.toList());
            List<Boolean> results = executeTasks(tasks);
            return results.stream().anyMatch(Boolean::booleanValue);
        }
    }

    @Override
    public <T> int count(int threads, List<? extends T> values,
                         Predicate<? super T> predicate) throws InterruptedException {
        return count(threads, values, predicate, 1);
    }

    @Override
    public <T> int count(int threads, List<? extends T> values,
                         Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        if (mapper != null) {
            List<Integer> counts = mapper.map(
                    chunk -> (int) chunk.stream().filter(predicate).count(),
                    chunks
            );
            return counts.stream().mapToInt(Integer::intValue).sum();
        } else {
            List<Task<Integer>> tasks = chunks.stream()
                    .map(chunk -> (Task<Integer>) () -> (int) chunk.stream().filter(predicate).count())
                    .collect(Collectors.toList());
            List<Integer> results = executeTasks(tasks);
            return results.stream().mapToInt(Integer::intValue).sum();
        }
    }

    @Override
    public String join(int threads, List<?> values) throws InterruptedException {
        return join(threads, values, 1);
    }

    @Override
    public String join(int threads, List<?> values, int step) throws InterruptedException {
        List<?> stepValues = new StepList<>(values, step);
        List<List<?>> chunks = split(threads, stepValues);
        if (mapper != null) {
            List<String> results = mapper.map(
                    chunk -> chunk.stream().map(Object::toString).collect(Collectors.joining()),
                    chunks
            );
            return String.join("", results);
        } else {
            List<Task<String>> tasks = chunks.stream()
                    .map(chunk -> (Task<String>) () -> chunk.stream().map(Object::toString).collect(Collectors.joining()))
                    .collect(Collectors.toList());
            List<String> results = executeTasks(tasks);
            return String.join("", results);
        }
    }

    @Override
    public <T> List<T> filter(int threads, List<? extends T> values,
                              Predicate<? super T> predicate) throws InterruptedException {
        return filter(threads, values, predicate, 1);
    }

    @Override
    public <T> List<T> filter(int threads, List<? extends T> values,
                              Predicate<? super T> predicate, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        if (mapper != null) {
            List<List<T>> results = mapper.map(
                    chunk -> chunk.stream().filter(predicate).collect(Collectors.toList()),
                    chunks
            );
            return results.stream().flatMap(List::stream).collect(Collectors.toList());
        } else {
            List<Task<List<T>>> tasks = chunks.stream()
                    .map(chunk -> (Task<List<T>>) () -> chunk.stream().filter(predicate).collect(Collectors.toList()))
                    .collect(Collectors.toList());
            List<List<T>> results = executeTasks(tasks);
            return results.stream().flatMap(List::stream).collect(Collectors.toList());
        }
    }

    @Override
    public <T, U> List<U> map(int threads, List<? extends T> values,
                              Function<? super T, ? extends U> function) throws InterruptedException {
        return map(threads, values, function, 1);
    }

    @Override
    public <T, U> List<U> map(int threads, List<? extends T> values,
                              Function<? super T, ? extends U> function, int step) throws InterruptedException {
        List<? extends T> stepValues = new StepList<>(values, step);
        List<List<? extends T>> chunks = split(threads, stepValues);
        if (mapper != null) {
            List<List<U>> results = mapper.map(
                    chunk -> chunk.stream().map(function).collect(Collectors.toList()),
                    chunks
            );
            return results.stream().flatMap(List::stream).collect(Collectors.toList());
        } else {
            List<Task<List<U>>> tasks = chunks.stream()
                    .map(chunk -> (Task<List<U>>) () -> chunk.stream().map(function).collect(Collectors.toList()))
                    .collect(Collectors.toList());
            List<List<U>> results = executeTasks(tasks);
            return results.stream().flatMap(List::stream).collect(Collectors.toList());
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/mapper/ParallelMapperImpl.java ===
package info.kgeorgiy.ja.gusev.mapper;

import info.kgeorgiy.java.advanced.mapper.ParallelMapper;

import java.util.*;
import java.util.function.Function;

public class ParallelMapperImpl implements ParallelMapper {

    private final List<Thread> workers;
    private final Queue<Runnable> taskQueue;
    private volatile boolean isShutdown = false;

    public ParallelMapperImpl(int threads) {
        taskQueue = new ArrayDeque<>();
        workers = new ArrayList<>(threads);
        for (int i = 0; i < threads; i++) {
            Thread worker = new Thread(() -> {
                try {
                    while (!isShutdown) {
                        Runnable task;
                        synchronized (taskQueue) {
                            while (taskQueue.isEmpty() && !isShutdown) {
                                taskQueue.wait();
                            }
                            if (isShutdown && taskQueue.isEmpty()) {
                                break;  
                            }
                            task = taskQueue.poll();
                        }
                        if (task != null) {
                            task.run();
                        }
                    }
                } catch (InterruptedException ignored) {
                }
            });
            workers.add(worker);
            worker.start();
        }
    }

    @Override
    public <T, R> List<R> map(Function<? super T, ? extends R> function, List<? extends T> items) throws InterruptedException {
        List<R> results = new ArrayList<>(Collections.nCopies(items.size(), null));
        final Object lock = new Object();
        int tasksCount = items.size();
        final CountDownLatch latch = new CountDownLatch(tasksCount);  

        for (int i = 0; i < tasksCount; i++) {
            final int index = i;
            T item = items.get(index);
            synchronized (taskQueue) {
                taskQueue.add(() -> {
                    R result = function.apply(item);
                    synchronized (lock) {
                        results.set(index, result);
                    }
                    latch.countDown();
                });
                taskQueue.notify();  
            }
        }

        latch.await();  

        return results;
    }

    private static class CountDownLatch {
        private int count;

        public CountDownLatch(int count) {
            this.count = count;
        }

        public synchronized void countDown() {
            if (--count <= 0) {
                notifyAll();
            }
        }

        public synchronized void await() throws InterruptedException {
            while (count > 0) {
                wait();
            }
        }
    }

    @Override
    public void close() {
        synchronized (taskQueue) {
            isShutdown = true;
            taskQueue.notifyAll();  
        }
        for (Thread worker : workers) {
            try {
                worker.join();  
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/student/StudentDB.java ===
package info.kgeorgiy.ja.gusev.student;

import java.util.*;
import java.util.stream.Collectors;
import java.util.function.BinaryOperator;

import info.kgeorgiy.java.advanced.student.Group;
import info.kgeorgiy.java.advanced.student.GroupName;
import info.kgeorgiy.java.advanced.student.Student;
import info.kgeorgiy.java.advanced.student.StudentQuery;
import info.kgeorgiy.java.advanced.student.GroupQuery;

public class StudentDB implements StudentQuery, GroupQuery {

    
    
    @Override
    public List<String> getFirstNames(List<Student> students) {
        
        return students.stream().map(Student::getFirstName).collect(Collectors.toList());
    }

    @Override
    public List<String> getLastNames(List<Student> students) {
        
        return students.stream().map(Student::getLastName).collect(Collectors.toList());
    }

    @Override
    public List<GroupName> getGroups(List<Student> students) {
        
        return students.stream().map(Student::getGroup).collect(Collectors.toList());
    }

    @Override
    public List<String> getFullNames(List<Student> students) {
        
        return students.stream().map(s -> s.getFirstName() + " " + s.getLastName()).collect(Collectors.toList());
    }

    @Override
    public Set<String> getDistinctFirstNames(List<Student> students) {
        
        return students.stream().map(Student::getFirstName).collect(Collectors.toCollection(TreeSet::new));
    }

    @Override
    public String getMaxStudentFirstName(List<Student> students) {
        
        return students.stream().max(Comparator.comparingInt(Student::getId)).map(Student::getFirstName).orElse("");
    }

    @Override
    public List<Student> sortStudentsById(Collection<Student> students) {
        
        return students.stream().sorted(Comparator.comparingInt(Student::getId)).collect(Collectors.toList());
    }

    @Override
    public List<Student> sortStudentsByName(Collection<Student> students) {
        
        return students.stream()
                .sorted(Comparator.comparing(Student::getLastName)
                .thenComparing(Student::getFirstName)
                .thenComparing(Student::getId, Comparator.reverseOrder()))
                .collect(Collectors.toList());
    }

    @Override
    public List<Student> findStudentsByFirstName(Collection<Student> students, String name) {
        
        return students.stream()
                .filter(s -> s.getFirstName().equals(name))
                .sorted(Comparator.comparing(Student::getLastName)
                .thenComparing(Student::getFirstName)
                .thenComparing(Student::getId, Comparator.reverseOrder()))
                .collect(Collectors.toList());
    }

    @Override
    public List<Student> findStudentsByLastName(Collection<Student> students, String name) {
        
        return students.stream()
                .filter(s -> s.getLastName().equals(name))
                .sorted(Comparator.comparing(Student::getLastName)
                .thenComparing(Student::getFirstName)
                .thenComparing(Student::getId, Comparator.reverseOrder()))
                .collect(Collectors.toList());
    }

    @Override
    public List<Student> findStudentsByGroup(Collection<Student> students, GroupName group) {
        
        return students.stream()
                .filter(s -> s.getGroup().equals(group))
                .sorted(Comparator.comparing(Student::getLastName)
                .thenComparing(Student::getFirstName)
                .thenComparing(Student::getId, Comparator.reverseOrder()))
                .collect(Collectors.toList());
    }

    @Override
    public Map<String, String> findStudentNamesByGroup(Collection<Student> students, GroupName group) {
        
        return findStudentsByGroup(students, group).stream()
                .collect(Collectors.toMap(Student::getLastName, Student::getFirstName, BinaryOperator.minBy(String::compareTo)));
    }

    

    @Override
    public List<Group> getGroupsByName(Collection<Student> students) {
        
        return students.stream()
                .collect(Collectors.groupingBy(Student::getGroup)) 
                .entrySet().stream() 
                .map(entry -> new Group(entry.getKey(), sortStudentsByName(entry.getValue()))) 
                .sorted(Comparator.comparing(Group::getName)) 
                .collect(Collectors.toList());
    }

    @Override
    public List<Group> getGroupsById(Collection<Student> students) {
        
        return students.stream()
                .collect(Collectors.groupingBy(Student::getGroup)) 
                .entrySet().stream() 
                .map(entry -> new Group(entry.getKey(), sortStudentsById(entry.getValue()))) 
                .sorted(Comparator.comparing(Group::getName)) 
                .collect(Collectors.toList());
    }

    @Override
    public GroupName getLargestGroup(Collection<Student> students) {
        
        return students.stream()
                .collect(Collectors.groupingBy(Student::getGroup, Collectors.counting())) 
                .entrySet().stream() 
                .max(Comparator.comparingLong(Map.Entry<GroupName, Long>::getValue) 
                .thenComparing(Map.Entry::getKey)) 
                .map(Map.Entry::getKey)
                .orElse(null); 
    }


    @Override
    public GroupName getLargestGroupFirstName(Collection<Student> students) {
        
        return students.stream()
                .collect(Collectors.groupingBy(Student::getGroup,
                        Collectors.collectingAndThen(Collectors.mapping(Student::getFirstName, Collectors.toSet()), Set::size))) 
                .entrySet().stream() 
                .max(Comparator.comparingInt(Map.Entry<GroupName, Integer>::getValue) 
                .thenComparing(Map.Entry::getKey, Comparator.reverseOrder())) 
                .map(Map.Entry::getKey)
                .orElse(null); 
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/walk/Walk.java ===
package info.kgeorgiy.ja.gusev.walk;

import java.io.*;
import java.nio.file.*;

public class Walk {
    private static int calculateJenkinsHash(Path path) {
        int hash = 0;
        try (InputStream inputStream = Files.newInputStream(path)) {
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                for (int i = 0; i < bytesRead; i++) {
                    hash += (buffer[i] & 0xFF);
                    hash += (hash << 10);
                    hash ^= (hash >>> 6);
                }
            }
            hash += (hash << 3);
            hash ^= (hash >>> 11);
            hash += (hash << 15);
        } catch (IOException e) {
            hash = 0;
        }
        return hash;
    }

    private static void walk(String input, String output) {
        Path inputPath;
        Path outputPath;

        try {
            inputPath = Paths.get(input);
            outputPath = Paths.get(output);
        } catch (InvalidPathException e) {
            System.err.println("ERROR: InvalidPathException: " + e.getMessage());
            return;
        }

        if (outputPath.getParent() != null) {
            try {
                Files.createDirectories(outputPath.getParent());
            } catch (IOException e) {
                System.err.println("ERROR: IOException can't create folder for output file: " + e.getMessage());
                return;
            }
        }

        try (BufferedReader reader = Files.newBufferedReader(inputPath)) {
            try (BufferedWriter writer = Files.newBufferedWriter(outputPath)) {
                String filePathString;

                while ((filePathString = reader.readLine()) != null) {
                    try {
                        Path filePath = Paths.get(filePathString);
                        writer.write(String.format("%08x %s", calculateJenkinsHash(filePath), filePath.toString()));
                        writer.newLine();
                    } catch (InvalidPathException e) {
                        writer.write(String.format("%08x %s", 0, filePathString));
                        writer.newLine();
                    }
                }
            } catch (IOException e) {
                System.err.println("ERROR: IOException while writing to output file: " + e.getMessage());
            }
        } catch (IOException e) {
            System.err.println("ERROR: IOException while reading from input file: " + e.getMessage());
        }
    }

    public static void main(String[] args) {
        if (args == null || args.length != 2 || args[0] == null || args[1] == null) {
            System.err.println("Usage: java Walk <input file> <output file>");
        } else {
            walk(args[0], args[1]);
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/walk/RecursiveWalk.java ===
package info.kgeorgiy.ja.gusev.walk;

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

public class RecursiveWalk {
    private static int calculateJenkinsHash(Path path) {
        int hash = 0;
        try (InputStream inputStream = Files.newInputStream(path)) {
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                for (int i = 0; i < bytesRead; i++) {
                    hash += (buffer[i] & 0xFF);
                    hash += (hash << 10);
                    hash ^= (hash >>> 6);
                }
            }
            hash += (hash << 3);
            hash ^= (hash >>> 11);
            hash += (hash << 15);
        } catch (IOException e) {
            hash = 0;
        }
        return hash;
    }

    private static void walk(String input, String output) {
        Path inputPath;
        Path outputPath;

        try {
            inputPath = Paths.get(input);
            outputPath = Paths.get(output);
        } catch (InvalidPathException e) {
            System.err.println("ERROR: InvalidPathException: " + e.getMessage());
            return;
        }

        if (outputPath.getParent() != null) {
            try {
                Files.createDirectories(outputPath.getParent());
            } catch (IOException e) {
                System.err.println("ERROR: IOException can't create folder for output file: " + e.getMessage());
                return;
            }
        }

        try (BufferedReader reader = Files.newBufferedReader(inputPath)) {
            try (BufferedWriter writer = Files.newBufferedWriter(outputPath)) {
                String filePathString;

                while ((filePathString = reader.readLine()) != null) {
                    try {
                        Path filePath = Paths.get(filePathString);

                        Files.walkFileTree(filePath, new SimpleFileVisitor<>() {
                            @Override
                            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                                writer.write(String.format("%08x %s", calculateJenkinsHash(file), file.toString()));
                                writer.newLine();
                                return FileVisitResult.CONTINUE;
                            }

                            @Override
                            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                                writer.write(String.format("%08x %s", 0, file.toString()));
                                writer.newLine();
                                return FileVisitResult.CONTINUE;
                            }
                        });
                    } catch (InvalidPathException e) {
                        writer.write(String.format("%08x %s", 0, filePathString));
                        writer.newLine();
                    }
                }
            } catch (IOException e) {
                System.err.println("ERROR: IOException while writing to output file: " + e.getMessage());
            }
        } catch (IOException e) {
            System.err.println("ERROR: IOException while reading from input file: " + e.getMessage());
        }
    }

    public static void main(String[] args) {
        if (args == null || args.length != 2 || args[0] == null || args[1] == null) {
            System.err.println("Usage: java RecursiveWalk <input file> <output file>");
        } else {
            walk(args[0], args[1]);
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/tracingproxy/tests/Calculator.java ===
package info.kgeorgiy.ja.gusev.tracingproxy.tests;

public interface Calculator {
    int add(int a, int b);
    int subtract(int a, int b);
    int divide(int a, int b);
    Calculator getCalculator();
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/tracingproxy/tests/SimpleCalculator.java ===
package info.kgeorgiy.ja.gusev.tracingproxy.tests;

public class SimpleCalculator implements Calculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int subtract(int a, int b) {
        return a - b;
    }

    @Override
    public int divide(int a, int b) {
        return a / b; // Бросит ArithmeticException, если b == 0
    }

    @Override
    public Calculator getCalculator() {
        return this;
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/tracingproxy/tests/TracingProxyTest.java ===
package info.kgeorgiy.ja.gusev.tracingproxy.tests;

import info.kgeorgiy.ja.gusev.tracingproxy.TracingProxy;

// Простые тесты для базовой проверки работоспособности кода

public class TracingProxyTest {
    public static void main(String[] args) {
        Calculator calculator = new SimpleCalculator();

        Calculator proxy = (Calculator) TracingProxy.create(calculator, 2);

        int result1 = proxy.add(5, 3);
        System.out.println("Result of add: " + result1);
        System.out.println();

        int result2 = proxy.subtract(10, 4);
        System.out.println("Result of subtract: " + result2);
        System.out.println();

        Calculator nestedProxy = proxy.getCalculator();
        int result3 = nestedProxy.add(2, 2);
        System.out.println("Result of nested add: " + result3);
        System.out.println();

        try {
            proxy.divide(10, 0); // Должно вызвать ArithmeticException
        } catch (Exception e) {
            System.out.println("Caught exception: " + e);
        }
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/tracingproxy/TracingProxy.java ===
package info.kgeorgiy.ja.gusev.tracingproxy;

import java.lang.reflect.*;
import java.util.Arrays;
import java.util.stream.Collectors;

// 99. TracingProxy

// Задача фактически заключается в написании класса, реализующего интерфейс InvocationHandler из пакета java.lang.reflect
public class TracingProxy implements InvocationHandler {

    private final Object target; // Integer(5); 
    private final int depth;
    
    private TracingProxy(Object target, int depth) {
        this.target = target;
        this.depth = depth;
    }

// Статический метод для создания прокси-объекта
    public static Object create(Object target, int depth) {
        if (target == null) {
            throw new IllegalArgumentException("Target object cannot be null");
        }
        if (depth < 0) {
            throw new IllegalArgumentException("Depth cannot be negative");
        }
        Class<?> targetClass = target.getClass();
        Class<?>[] interfaces = getAllInterfaces(targetClass);

        if (interfaces.length == 0) {
            throw new IllegalArgumentException("Target object does not implement any interfaces");
        }

        return Proxy.newProxyInstance(
                targetClass.getClassLoader(),
                interfaces,
                new TracingProxy(target, depth)
        );
    }

// Метод, возвращающий массив всех интерфейсов, реализованных классом и его суперклассами
    private static Class<?>[] getAllInterfaces(Class<?> clazz) {
        if (clazz == null) {
            return new Class<?>[0];
        }
        Class<?>[] interfaces = clazz.getInterfaces();
        Class<?>[] superInterfaces = getAllInterfaces(clazz.getSuperclass());
        Class<?>[] allInterfaces = Arrays.copyOf(interfaces, interfaces.length + superInterfaces.length);
        System.arraycopy(superInterfaces, 0, allInterfaces, interfaces.length, superInterfaces.length);
        return Arrays.stream(allInterfaces).distinct().toArray(Class<?>[]::new);
    }

// Метод перехвата вызовов методов прокси-объекта.
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        logMethodCall(method, args);

        try {
            Object result = method.invoke(target, args);

            logMethodReturn(method, result);

            if (depth > 0 && result != null && !isPrimitiveOrWrapper(result.getClass())) {
                result = create(result, depth - 1);
            }

            return result;
        } catch (InvocationTargetException e) {
            logMethodException(method, e.getCause());
            throw e.getCause();
        }
    }


// Вспомогательный метод; логирующие методы

    private boolean isPrimitiveOrWrapper(Class<?> clazz) {
        return clazz.isPrimitive() || clazz == Boolean.class || clazz == Byte.class
                || clazz == Character.class || clazz == Short.class || clazz == Integer.class
                || clazz == Long.class || clazz == Float.class || clazz == Double.class
                || clazz == Void.class || clazz == String.class;
    }
    
    private void logMethodCall(Method method, Object[] args) {
        String argsString = (args == null || args.length == 0) ? "" : Arrays.stream(args)
                .map(String::valueOf) 
                .collect(Collectors.joining(", "));
        System.out.println("Calling method: " + method.getName() + "(" + argsString + ")");
    }

    private void logMethodReturn(Method method, Object result) {
        if (!method.getReturnType().equals(void.class)) {
            System.out.println("Method " + method.getName() + " returned: " + result);
        } else {
            System.out.println("Method " + method.getName() + " completed");
        }
    }

    private void logMethodException(Method method, Throwable throwable) {
        System.out.println("Method " + method.getName() + " threw exception: " + throwable);
    }
}


=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/scr.bash ===
#!/bin/bash

# Переменная для хранения имени выходного файла
OUTPUT_FILE="directory_structure.txt"

# Вывод структуры текущей директории с помощью ls -a и tree -a
{
  echo "=== Структура каталога (ls -a) ==="
  ls -a
  echo ""
  
  echo "=== Структура каталога (tree -a) ==="
  tree -a
  echo ""
} > "$OUTPUT_FILE"

# Рекурсивный проход по всем файлам и каталогам в текущей директории
find "$(pwd)" -type f | while read -r file; do
  # Проверяем, является ли файл небинарным
  if file "$file" | grep -q "text"; then
    {
      echo "=== Содержимое файла: $file ==="
      cat "$file"
      echo ""
    } >> "$OUTPUT_FILE"
  fi
done

echo "Результат записан в файл $OUTPUT_FILE"

=== Содержимое файла: /home/gs0xa19f2/Documents/ITMO/Programming Technologies: Java Advanced/directory_structure.txt ===

